use bevy::prelude::*;

use super::{
    view::{Cx, ElementContext},
    NodeSpan, View,
};

#[derive(Resource)]
pub struct ViewRootResource(pub ViewRoot);

#[derive(Component)]
pub struct ViewRoot {
    pub handle: Option<Box<dyn AnyViewState>>,
}

impl ViewRoot {
    /// Construct a new ViewRoot from a presenter and props.
    pub fn new<V: View + 'static, Props: Send + Sync + 'static + Clone>(
        presenter: fn(cx: Cx<Props>) -> V,
        props: Props,
    ) -> Self {
        Self {
            handle: Some(Box::new(ViewState::new(presenter, props))),
        }
    }

    /// Return the count of top-level UiNodes
    pub fn count(&self) -> usize {
        self.handle.as_ref().unwrap().count()
    }

    /// Rebuild the UiNodes.
    pub fn build(&mut self, world: &mut World, entity: Entity) {
        let mut ec = ElementContext { world };
        self.handle.as_mut().unwrap().build(&mut ec, entity);
    }
}

// pub struct ViewHandle {
//     pub(crate) state: Box<dyn AnyViewHandle>,
// }

#[derive(Component)]
pub struct ViewStateComp {
    pub handle: Box<dyn AnyViewState>,
}

impl ViewStateComp {
    /// Construct a new ViewRoot from a presenter and props.
    pub fn new<V: View + 'static, Props: Send + Sync + 'static + Clone>(
        presenter: fn(cx: Cx<Props>) -> V,
        props: Props,
    ) -> Self {
        Self {
            handle: Box::new(ViewState::new(presenter, props)),
        }
    }
}

#[derive(Component)]
struct NeedsRebuild;

pub struct ViewState<V: View, Props: Send + Sync> {
    presenter: fn(cx: Cx<Props>) -> V,
    nodes: NodeSpan,
    props: Props,
    state: V::State,
}

impl<V: View, Props: Send + Sync> ViewState<V, Props> {
    pub fn new(presenter: fn(cx: Cx<Props>) -> V, props: Props) -> Self {
        Self {
            presenter,
            nodes: NodeSpan::Empty,
            props,
            state: Default::default(),
        }
    }
}

pub trait AnyViewState: Send + Sync {
    // Return the number of top-level UiNodes generated by this view.
    fn count(&self) -> usize;

    // Return the nodes that were generated by this view.
    fn nodes(&self, prev: &NodeSpan) -> NodeSpan;

    // Rebuild the NodeSpans for this view and update the state.
    fn build<'w>(&mut self, cx: &'w mut ElementContext<'w>, entity: Entity);
}

impl<V: View, Props: Send + Sync + Clone> AnyViewState for ViewState<V, Props> {
    fn count(&self) -> usize {
        self.nodes.count()
    }

    fn build<'w>(&mut self, ecx: &'w mut ElementContext<'w>, entity: Entity) {
        let cx = Cx::<Props> {
            sys: ecx,
            props: &self.props,
            entity,
        };
        let v = (self.presenter)(cx);
        self.nodes = v.build(ecx, &mut self.state, &self.nodes);
    }

    fn nodes(&self, _prev: &NodeSpan) -> NodeSpan {
        self.nodes.clone()
    }
}
