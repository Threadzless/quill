use std::{
    any::Any,
    sync::{Arc, Mutex},
};

use bevy::{prelude::*, utils::HashSet};

use crate::{
    tracked_resources::TrackedResources,
    tracking::{OwnedEntities, TrackedComponents},
    BuildContext, NodeSpan, PresenterFn, TrackingContext,
};

use super::{cx::Cx, View};

/// A ViewHandle holds a type-erased reference to a presenter function and its props and state.
#[derive(Component)]
pub struct ViewHandle {
    /// A reference to the type-erased presenter state.
    pub(crate) inner: Arc<Mutex<dyn AnyPresenterState>>,
}

impl ViewHandle {
    /// Construct a new ViewRoot from a presenter and props.
    pub fn new<Marker, P: PresenterFn<Marker>>(presenter: P, props: P::Props) -> Self {
        Self {
            inner: Arc::new(Mutex::new(PresenterState::new(presenter, props))),
        }
    }

    /// Construct a new ViewRoot from an already boxed presenter and props.
    pub fn from_boxed(bind: Arc<Mutex<dyn AnyPresenterState>>) -> Self {
        Self {
            inner: bind.clone(),
        }
    }

    /// Return the display nodes that were generated by this view.
    pub fn nodes(&self) -> NodeSpan {
        self.inner.lock().unwrap().nodes()
    }

    /// Update the copy of props in this view state.
    pub fn update_props<'a>(&mut self, props: &'a mut dyn Any) -> bool {
        self.inner.lock().unwrap().update_props(props)
    }
}

/// `ViewState` contains all of the data needed to re-render a presenter: The presenter function,
/// its properties, its state, and the cached output nodes.
///
/// This type is generic on the props and state for the presenter.
pub struct PresenterState<Marker: 'static, F: PresenterFn<Marker>> {
    /// Reference to presenter function
    presenter: F,

    /// Props passed to the presenter
    props: F::Props,

    /// View tree output by presenter
    view: Option<F::View>,

    /// Externalized state defined by view tree
    state: Option<<F::View as View>::State>,

    /// The UiNodes generated by this view state
    nodes: NodeSpan,
}

impl<Marker, F: PresenterFn<Marker>> PresenterState<Marker, F> {
    pub fn new(presenter: F, props: F::Props) -> Self {
        Self {
            presenter,
            nodes: NodeSpan::Empty,
            props,
            view: None,
            state: Option::None,
        }
    }
}

/// `AnyViewState` is a type-erased version of `ViewState`. It allows holding a reference
/// to a renderable presenter without knowing the type of its props and state.
pub trait AnyPresenterState: Send {
    /// Return the nodes that were generated by this view.
    fn nodes(&self) -> NodeSpan;

    /// Rebuild the NodeSpans for this view and update the state.
    fn build(&mut self, vc: &mut BuildContext, entity: Entity);

    /// Release all state and despawn all child entities.
    fn raze(&mut self, world: &mut World, entity: Entity);

    /// Rebuild the display graph connections.
    fn attach(&mut self, vc: &mut BuildContext, entity: Entity);

    /// Update the copy of props in this view state.
    fn update_props<'a>(&mut self, props: &'a mut dyn Any) -> bool;

    /// Update the copy of props in this view state.
    fn get_props<'a>(&'a mut self) -> &'a mut dyn Any;
}

impl<Marker, F: PresenterFn<Marker>> AnyPresenterState for PresenterState<Marker, F> {
    fn build(&mut self, vc: &mut BuildContext, entity: Entity) {
        let atom_handles: Vec<Entity> = match vc.world.entity(entity).get::<OwnedEntities>() {
            Some(owned) => owned.0.clone(),
            None => Vec::new(),
        };
        let mut child_context = vc.for_entity(entity);
        let mut tracking = TrackingContext {
            resources: Vec::new(),
            components: HashSet::new(),
            next_entity_index: 0,
            owned_entities: atom_handles,
        };
        let cx = Cx::new(&self.props, &mut child_context, &mut tracking);
        self.view = Some(self.presenter.call(cx));
        match self.state {
            Some(ref mut state) => {
                self.view
                    .as_ref()
                    .unwrap()
                    .update(&mut child_context, state);
                self.attach(vc, entity);
            }
            None => {
                let state = self.view.as_ref().unwrap().build(&mut child_context);
                self.state = Some(state);
                vc.mark_changed_shape();
                if let Some(parent) = vc.entity(vc.entity).get::<Parent>() {
                    vc.entity_mut(parent.get()).insert(PresenterGraphChanged);
                }
            }
        };

        let mut entt = vc.world.entity_mut(entity);
        if tracking.resources.len() > 0 {
            entt.insert(TrackedResources {
                data: tracking.resources,
            });
        } else {
            entt.remove::<TrackedResources>();
        }

        if tracking.components.len() > 0 {
            entt.insert(TrackedComponents {
                data: tracking.components,
            });
        } else {
            entt.remove::<TrackedComponents>();
        }

        if tracking.owned_entities.len() > 0 {
            entt.insert(OwnedEntities(tracking.owned_entities));
        } else {
            entt.remove::<OwnedEntities>();
        }
    }

    fn raze(&mut self, world: &mut World, entity: Entity) {
        if let Some(ref view) = self.view {
            // Despawn the presenter state entity.
            if let Some(ref mut state) = self.state {
                view.raze(world, state);
            }
            self.view = None;
            self.state = None;
        }

        // Release all owned entities.
        if let Some(mut handles) = world.entity_mut(entity).get_mut::<OwnedEntities>() {
            let mut handles_copy: Vec<Entity> = Vec::new();
            std::mem::swap(&mut handles.0, &mut handles_copy);
            for handle in handles_copy.iter() {
                world.despawn(*handle);
            }
        }
    }

    fn attach(&mut self, vc: &mut BuildContext, entity: Entity) {
        let mut child_context = vc.for_entity(entity);
        let nodes = self
            .view
            .as_ref()
            .unwrap()
            .assemble(&mut child_context, &mut self.state.as_mut().unwrap());
        if self.nodes != nodes {
            self.nodes = nodes;
            // Parent needs to rebuild children
            if let Some(parent) = vc.entity(vc.entity).get::<Parent>() {
                vc.entity_mut(parent.get()).insert(PresenterGraphChanged);
            }
        }
    }

    fn nodes(&self) -> NodeSpan {
        self.nodes.clone()
    }

    fn update_props<'a>(&mut self, new_props: &'a mut dyn Any) -> bool {
        let new_props = new_props
            .downcast_mut::<F::Props>()
            .expect("Mismatched props type");

        if self.props != *new_props {
            std::mem::swap::<F::Props>(new_props, &mut self.props);
            // self.props.clone_from(new_props);
            true
        } else {
            false
        }
    }

    fn get_props<'a>(&'a mut self) -> &'a mut dyn Any {
        &mut self.props
    }
}

/// Marker component that lets us know when the internal state of a presenter needs to be
/// rebuilt.
#[derive(Component)]
pub struct PresenterStateChanged;

/// Marker component that lets us know when the display graph for a presenter needs to be
/// rebuilt.
#[derive(Component)]
pub struct PresenterGraphChanged;
