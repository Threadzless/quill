use std::any::Any;

use bevy::prelude::*;

use crate::NodeSpan;

use super::{
    cx::{Cx, ElementContext},
    View,
};

/// A ViewHandle holds a type-erased reference to a presenter function and its props and state.
#[derive(Component)]
pub struct ViewHandle {
    pub inner: Option<Box<dyn AnyViewState>>,
}

impl ViewHandle {
    /// Construct a new ViewRoot from a presenter and props.
    pub fn new<
        V: View + 'static,
        Props: Send + Sync + Clone + 'static,
        F: FnMut(Cx<Props>) -> V + Send + Sync + 'static,
    >(
        presenter: F,
        props: Props,
    ) -> Self {
        Self {
            inner: Some(Box::new(ViewState::new(presenter, props))),
        }
    }
}

/// `ViewState` contains all of the data needed to re-render a presenter: The presenter function,
/// its properties, its state, and the cached output nodes.
///
/// This type is generic on the props and state for the presenter.
pub struct ViewState<V: View, Props: Send + Sync, F: FnMut(Cx<Props>) -> V> {
    /// Reference to presenter function
    presenter: F,

    /// Props passed to the presenter
    props: Props,

    /// View tree output by presenter
    view: Option<V>,

    /// Externalized state defined by view tree
    state: V::State,

    /// The UiNodes generated by this view state
    nodes: NodeSpan,
}

impl<V: View, Props: Send + Sync, F: FnMut(Cx<Props>) -> V> ViewState<V, Props, F> {
    pub fn new(presenter: F, props: Props) -> Self {
        Self {
            presenter,
            nodes: NodeSpan::Empty,
            props,
            view: None,
            state: Default::default(),
        }
    }
}

/// `AnyViewState` is a type-erased version of `ViewState`. It allows holding a reference
/// to a renderable presenter without knowing the type of its props and state.
pub trait AnyViewState: Send + Sync {
    /// Return the nodes that were generated by this view.
    fn nodes(&self, prev: &NodeSpan) -> NodeSpan;

    /// Rebuild the NodeSpans for this view and update the state.
    fn build(&mut self, ecx: &mut ElementContext, entity: Entity);

    /// Release all state and despawn all child entities.
    fn raze(&mut self, ecx: &mut ElementContext, entity: Entity);

    /// Rebuild the display graph connections.
    fn assemble(&mut self, ecx: &mut ElementContext, entity: Entity);

    /// Update the copy of props in this view state.
    fn update_props<'a>(&mut self, props: &'a dyn Any);
}

impl<V: View, Props: Send + Sync + Clone + 'static, F: FnMut(Cx<Props>) -> V + Send + Sync>
    AnyViewState for ViewState<V, Props, F>
{
    fn build(&mut self, ecx: &mut ElementContext, entity: Entity) {
        let mut child_context = ElementContext {
            world: ecx.world,
            entity,
        };
        let cx = Cx::<Props> {
            sys: &mut child_context,
            props: &self.props,
            local_index: 0,
        };
        self.view = Some((self.presenter)(cx));
        self.view
            .as_ref()
            .unwrap()
            .build(&mut child_context, &mut self.state, &self.nodes);
        // if self.nodes != nodes {
        //     self.nodes = nodes;
        //     // Parent needs to rebuild children
        //     if let Some(parent) = ecx.world.entity(ecx.entity).get::<Parent>() {
        //         ecx.world
        //             .entity_mut(parent.get())
        //             .insert(PresenterGraphChanged);
        //     }
        // }
    }

    fn raze(&mut self, ecx: &mut ElementContext, entity: Entity) {
        let mut child_context = ElementContext {
            world: ecx.world,
            entity,
        };
        if let Some(ref view) = self.view {
            view.raze(&mut child_context, &mut self.state, &self.nodes);
            self.view = None;
        }
    }

    fn assemble(&mut self, ecx: &mut ElementContext, entity: Entity) {
        let mut child_context = ElementContext {
            world: ecx.world,
            entity,
        };
        let nodes =
            self.view
                .as_ref()
                .unwrap()
                .collect(&mut child_context, &mut self.state, &self.nodes);
        if self.nodes != nodes {
            self.nodes = nodes;
            // Parent needs to rebuild children
            if let Some(parent) = ecx.world.entity(ecx.entity).get::<Parent>() {
                ecx.world
                    .entity_mut(parent.get())
                    .insert(PresenterGraphChanged);
            }
        }
    }

    fn nodes(&self, _prev: &NodeSpan) -> NodeSpan {
        self.nodes.clone()
    }

    fn update_props<'a>(&mut self, new_props: &'a dyn Any) {
        self.props.clone_from(
            new_props
                .downcast_ref::<Props>()
                .expect("Mismatched props type"),
        );
    }
}

/// Marker component that lets us know when the display graph for a presenter needs to be
/// rebuilt.
#[derive(Component)]
pub struct PresenterGraphChanged;
